<div x-data="sshTerminalModal()" @open-ssh-terminal.window="openModal($event.detail)" class="ssh-modal-wrapper"
    x-show="isOpen" x-transition.opacity style="display: none;">

    <style>
        /* Custom scrollbar for xterm - Light theme version */
        #ssh-terminal-container .xterm-viewport::-webkit-scrollbar {
            width: 8px !important;
            height: 0px !important;
            background: transparent !important;
        }

        #ssh-terminal-container .xterm-viewport::-webkit-scrollbar-track {
            background: #fdfdfd !important;
            border: none !important;
        }

        #ssh-terminal-container .xterm-viewport::-webkit-scrollbar-thumb {
            background: #e5e7eb !important;
            border-radius: 4px !important;
        }

        #ssh-terminal-container .xterm-viewport::-webkit-scrollbar-thumb:hover {
            background: #d1d5db !important;
        }

        /* Ensure the viewport only scrolls vertically and hides track when unnecessary */
        #ssh-terminal-container .xterm-viewport {
            overflow-y: auto !important;
            overflow-x: hidden !important;
            background: transparent !important;
        }

        #ssh-terminal-container .xterm-screen {
            background: transparent !important;
        }
    </style>

    <dialog open x-show="isOpen" x-transition.scale style="background: transparent; border: none; padding: 0;">
        <article class="modal-content"
            style="min-width: 800px; width: 90vw; max-width: 1200px; border-radius: 12px; overflow: hidden; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.1); border: 1px solid #e5e7eb; background: #ffffff;">
            <header
                style="background: #ffffff; padding: 1.5rem 1.5rem 1rem 1.5rem; display: flex; justify-content: space-between; align-items: center;">
                <h2 style="margin: 0; font-size: 1.25rem; font-weight: 600; color: #111827;">Terminal: <span
                        x-text="alias"></span></h2>
                <button @click="closeModal()"
                    style="background: transparent; border: none; padding: 4px; cursor: pointer; color: #9ca3af;"
                    title="Close">
                    <i data-lucide="x" style="width: 20px; height: 20px;"></i>
                </button>
            </header>

            <div style="padding: 0 1.5rem 1.5rem 1.5rem; background: #ffffff;">
                <!-- Light "Editor-style" box for the terminal -->
                <div
                    style="background: #ffffff; border: 1px solid #e5e7eb; border-radius: 8px; padding: 20px; overflow: hidden;">
                    <div id="ssh-terminal-container"
                        style="height: 600px; width: 100%; background: transparent; outline: none; overflow: hidden;"
                        tabindex="0" @click="term && term.focus()">
                    </div>
                </div>
            </div>
        </article>
    </dialog>
</div>

<script>
    document.addEventListener('alpine:init', () => {
        Alpine.data('sshTerminalModal', () => ({
            isOpen: false,
            hostId: null,
            alias: '',
            term: null,
            fitAddon: null,
            socket: null,

            openModal(detail) {
                console.log(`[Sible] Terminal modal triggered for host ${detail.hostId}`);
                this.hostId = detail.hostId;
                this.alias = detail.alias;
                this.isOpen = true;
                this.$nextTick(() => {
                    try {
                        this.initTerminal();
                    } catch (e) {
                        console.error('[Sible] Terminal init failed:', e);
                        window.dispatchEvent(new CustomEvent('show-toast', {
                            detail: { message: "Terminal Init Failed: " + e.message, level: 'error' }
                        }));
                    }
                });
            },

            closeModal() {
                this.isOpen = false;
                if (this.socket) {
                    this.socket.close();
                }
                if (this.term) {
                    this.term.dispose();
                    this.term = null;
                }
                this.hostId = null;
            },

            initTerminal() {
                const container = document.getElementById('ssh-terminal-container');
                if (!container) throw new Error("Terminal container not found");

                container.innerHTML = ''; // Clear previous

                if (typeof Terminal === 'undefined' || typeof FitAddon === 'undefined') {
                    throw new Error("xterm.js libraries not loaded");
                }

                this.term = new Terminal({
                    cursorBlink: true,
                    disableStdin: false,
                    allowTransparency: true,
                    theme: {
                        background: '#ffffff',
                        foreground: '#1f2937',
                        cursor: '#111827',
                        selectionBackground: 'rgba(0, 0, 0, 0.1)',
                        black: '#000000',
                        red: '#dc2626',
                        green: '#16a34a',
                        yellow: '#d97706',
                        blue: '#2563eb',
                        magenta: '#9333ea',
                        cyan: '#0891b2',
                        white: '#f3f4f6',
                        brightBlack: '#4b5563',
                        brightRed: '#ef4444',
                        brightGreen: '#22c55e',
                        brightYellow: '#f59e0b',
                        brightBlue: '#3b82f6',
                        brightMagenta: '#a855f7',
                        brightCyan: '#06b6d4',
                        brightWhite: '#ffffff'
                    },
                    fontSize: 13,
                    fontFamily: "'Geist Mono', 'SF Mono', 'Menlo', monospace"
                });

                this.fitAddon = new FitAddon.FitAddon();
                this.term.loadAddon(this.fitAddon);
                this.term.open(container);

                // Multiple fits to handle transitions
                this.fitAddon.fit();
                setTimeout(() => {
                    this.fitAddon.fit();
                    this.onResize();
                }, 100);
                setTimeout(() => {
                    this.fitAddon.fit();
                    this.onResize();
                }, 500);

                // CRITICAL: Focus with a slight delay to ensure the modal transition is complete
                setTimeout(() => {
                    this.term.focus();
                }, 400);

                // Connect WebSocket
                this.connectWebSocket();

                // Handle Resize
                this.term.onResize(size => {
                    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                        this.socket.send(JSON.stringify({
                            type: 'resize',
                            cols: size.cols,
                            rows: size.rows
                        }));
                    }
                });

                window.addEventListener('resize', this.onResize.bind(this));
            },

            onResize() {
                if (this.isOpen && this.fitAddon) {
                    try {
                        this.fitAddon.fit();
                    } catch (e) { console.warn("Fit error", e); }
                }
            },

            connectWebSocket() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                // Get token from cookie
                const cookies = document.cookie.split('; ');
                const tokenCookie = cookies.find(row => row.startsWith('access_token='));
                const token = tokenCookie ? tokenCookie.split('=')[1] : '';

                const url = `${protocol}//${window.location.host}/ws/ssh/${this.hostId}${token ? '?token=' + token : ''}`;

                this.socket = new WebSocket(url);
                this.socket.binaryType = 'arraybuffer'; // Handle binary from SSH

                this.socket.onopen = () => {
                    this.term.write('\r\n\x1b[32mConnecting to SSH...\x1b[0m\r\n');
                    setTimeout(() => {
                        this.term.focus();
                        this.onResize(); // Initial resize sync
                    }, 400);
                };

                this.socket.onmessage = (event) => {
                    if (event.data instanceof ArrayBuffer) {
                        this.term.write(new Uint8Array(event.data));
                    } else {
                        this.term.write(event.data);
                    }
                };

                this.socket.onclose = (event) => {
                    this.term.write('\r\n\x1b[31mConnection closed.\x1b[0m\r\n');

                    if (event.code === 4001) {
                        window.dispatchEvent(new CustomEvent('show-toast', {
                            detail: {
                                message: "Connection Failed: " + (event.reason || "Unknown Error"),
                                level: 'error'
                            }
                        }));
                    }
                };

                this.socket.onerror = (error) => {
                    console.error('WebSocket Error:', error);
                    // Often onerror fires before onclose for connection failures
                    window.dispatchEvent(new CustomEvent('show-toast', {
                        detail: {
                            message: "Connection Error: check console for details",
                            level: 'error'
                        }
                    }));
                };

                this.term.onData((data) => {
                    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                        // Send as object to distinguish from control messages if needed
                        // but for now keep raw for input
                        this.socket.send(JSON.stringify({
                            type: 'input',
                            data: data
                        }));
                    } else {
                        console.warn('[Sible] Socket not open, ignoring input');
                    }
                });
            }
        }));
    });
</script>