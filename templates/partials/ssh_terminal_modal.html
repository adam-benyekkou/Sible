<div x-data="sshTerminalModal()" @open-ssh-terminal.window="openModal($event.detail)" class="ssh-modal-wrapper"
    x-show="isOpen" x-transition.opacity style="display: none;">

    <dialog open x-show="isOpen" x-transition.scale>
        <article class="modal-content" style="min-width: 800px; width: 90vw; max-width: 1200px;">
            <header
                style="background: rgba(255,255,255,0.8); border-bottom: 1px solid var(--ds-gray-200); padding: 1rem; display: flex; justify-content: space-between; align-items: center;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <i data-lucide="terminal" style="width: 18px; height: 18px; color: var(--ds-gray-1000);"></i>
                    <h5 style="margin: 0; font-size: 1rem; font-weight: 600;">Terminal: <span x-text="alias"></span>
                    </h5>
                </div>
                <button @click="closeModal()"
                    style="background: transparent; border: none; padding: 4px; cursor: pointer; color: var(--ds-gray-600);"
                    title="Close">
                    <i data-lucide="x" style="width: 20px; height: 20px;"></i>
                </button>
            </header>

            <div id="ssh-terminal-container" style="height: 600px; width: 100%; background: #ffffff; padding: 5px;">
            </div>


        </article>
    </dialog>
</div>

<script>
    document.addEventListener('alpine:init', () => {
        Alpine.data('sshTerminalModal', () => ({
            isOpen: false,
            hostId: null,
            alias: '',
            term: null,
            fitAddon: null,
            socket: null,

            openModal(detail) {
                this.hostId = detail.hostId;
                this.alias = detail.alias;
                this.isOpen = true;
                this.$nextTick(() => {
                    this.initTerminal();
                });
            },

            closeModal() {
                this.isOpen = false;
                if (this.socket) {
                    this.socket.close();
                }
                if (this.term) {
                    this.term.dispose();
                    this.term = null;
                }
                this.hostId = null;
            },

            initTerminal() {
                const container = document.getElementById('ssh-terminal-container');
                container.innerHTML = ''; // Clear previous

                this.term = new Terminal({
                    cursorBlink: true,
                    theme: {
                        background: '#ffffff',
                        foreground: '#000000',
                        cursor: '#000000',
                        selectionBackground: '#D7EAFF',
                        black: '#000000',
                        red: '#EE0000',
                        green: '#10B981',
                        yellow: '#F59E0B',
                        blue: '#0070F3',
                        magenta: '#D235A0',
                        cyan: '#00E5FF',
                        white: '#FFFFFF',
                        brightBlack: '#666666',
                        brightRed: '#EE0000',
                        brightGreen: '#10B981',
                        brightYellow: '#F59E0B',
                        brightBlue: '#0070F3',
                        brightMagenta: '#D235A0',
                        brightCyan: '#00E5FF',
                        brightWhite: '#FFFFFF'
                    },
                    fontSize: 13,
                    fontFamily: "'Geist Mono', 'SF Mono', 'Menlo', monospace"
                });

                this.fitAddon = new FitAddon.FitAddon();
                this.term.loadAddon(this.fitAddon);
                this.term.open(container);
                this.fitAddon.fit();

                // Connect WebSocket
                this.connectWebSocket();

                // Handle Resize
                window.addEventListener('resize', () => {
                    if (this.isOpen && this.fitAddon) {
                        this.fitAddon.fit();
                        // Optional: Send resize event to backend if supported
                    }
                });
            },

            connectWebSocket() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                // Get token from cookie
                const cookies = document.cookie.split('; ');
                const tokenCookie = cookies.find(row => row.startsWith('access_token='));
                const token = tokenCookie ? tokenCookie.split('=')[1] : '';

                const url = `${protocol}//${window.location.host}/ws/ssh/${this.hostId}${token ? '?token=' + token : ''}`;

                this.socket = new WebSocket(url);

                this.socket.onopen = () => {
                    this.term.write('\r\n\x1b[32mConnecting to SSH...\x1b[0m\r\n');
                };

                this.socket.onmessage = (event) => {
                    this.term.write(event.data);
                };

                this.socket.onclose = (event) => {
                    this.term.write('\r\n\x1b[31mConnection closed.\x1b[0m\r\n');

                    if (event.code === 4001) {
                        window.dispatchEvent(new CustomEvent('show-toast', {
                            detail: {
                                message: "Connection Failed: " + (event.reason || "Unknown Error"),
                                level: 'error'
                            }
                        }));
                    }
                };

                this.socket.onerror = (error) => {
                    console.error('WebSocket Error:', error);
                    // Often onerror fires before onclose for connection failures
                    window.dispatchEvent(new CustomEvent('show-toast', {
                        detail: {
                            message: "Connection Error: check console for details",
                            level: 'error'
                        }
                    }));
                };

                this.term.onData((data) => {
                    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                        this.socket.send(data);
                    }
                });
            }
        }));
    });
</script>